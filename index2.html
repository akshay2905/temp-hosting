
<!DOCTYPE html>
<meta charset="utf-8">
<style>

.country {
  fill: #b8b8b8;
  stroke: #fff;
  stroke-width: .5px;
  stroke-linejoin: round;
}

.graticule {
  fill: none;
  stroke: #000;
  stroke-opacity: .3;
  stroke-width: .5px;
}

.graticule-outline {
  fill: none;
  stroke: #333;
  stroke-width: 1.5px;
}

text {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 18px;
  font-weight: bold;
  text-anchor: middle;
}

</style>
<body>
    <script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/topojson.v0.min.js"></script>
<script>
var width = 600,
    height = 600;



console.log()
var points = [{
    type: "Point",
    coordinates: [12.972442, 77.580643],
    location: "Your Location",
    icon: "\uF015"
}, {
    type: "Point",
    coordinates: [34.8887969, 32.4406351],
    location: "Caribe Royale Orlando",
    icon: "\uF236"
}];

var canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height);

var c = canvas.node().getContext("2d");

var point = d3.geoCentroid(points[0]);

var projection = d3.geoOrthographic()
    .translate([width / 2, height / 2])
    .scale(width / 2)
    .clipAngle(90)
    .precision(0.6)
    .rotate([-point[0], -point[1]]);

var loftedProjection = d3.geoOrthographic()
    .scale((width / 2) * 1.2)
    .translate([width / 2, height / 2])
    .precision(0.1);

var path = d3.geoPath()
    .projection(projection)
    .context(c);

var swoosh = d3.line()
    .curve(d3.curveNatural)
    .context(c);

var colorLand = "#4d4f51",
    colorGlobe = "#2e3133",
    textColors = "#fff";

var flyingArcLength;

d3.json("world_countries.json", function (error, world) {
    if (error) throw error;

    console.log(world)
    var sphere = { type: "Sphere" },
        land = world.features//topojson.feature(world, world.objects.land),
        i = 0;

    var _transition;

    var gradient = c.createLinearGradient(0, 0, 170, 0);

    (function transition() {
        d3.transition()
            .duration(8000)
            .on("start", function () {
                points[i++];
            })
            .tween("rotate", tween)
            .on("end", i < points.length - 2 ? transition : restartTransition);
        _transition = transition;
    })();

    function tween() {
        var p = d3.geoCentroid(points[i]),
            r = d3.geoInterpolate(projection.rotate(), [-p[0], -p[1]]),
            oldPoint = i < 1 ? points[1] : points[0],
            coords = points[i].coordinates,
            flightPath = {
                type: 'Feature',
                geometry: {
                    type: "LineString",
                    coordinates: [oldPoint.coordinates, coords]
                }
            },
            startEndScale = width * 2,
            middleScale = width / 2,
            sM = d3.interpolate(startEndScale, middleScale),
            mE = d3.interpolate(middleScale, startEndScale),
            zoomingIn = false;
            
            var s = d3.interpolate(0.0000001,Math.PI);

        flyingArcLength = lineLength(flyingArc(flightPath));

        return function (t) {
            focusGlobeOnPoint(r(t), (1-Math.abs(Math.sin(s(t))))*startEndScale + Math.abs(Math.sin(s(t)))*middleScale);
            convertedLongLats = [projection(points[0].coordinates), projection(points[1].coordinates)]
            c.clearRect(0, 0, width, height);
            c.fillStyle = colorGlobe, c.beginPath(), path(sphere), c.fill();
            c.fillStyle = colorLand, c.beginPath(), path(land), c.fill();
            c.beginPath(), swoosh(flyingArc(flightPath)), c.setLineDash([t * flyingArcLength * 1.7, 1e6]), c.lineWidth = 2, c.strokeStyle = gradient, c.stroke();
            c.beginPath(), path(flightPath), c.setLineDash([t * flyingArcLength * 1.6, 1e6]), c.globalAlpha = 0.5, c.shadowColor = "#fff", c.shadowBlur = 5, c.lineWidth = 0.5, c.strokeStyle = "#fff", c.stroke(), c.shadowBlur = 0, c.globalAlpha = 1;
            for (var j = 0; j < points.length; j++) {
                var textCoords = projection(points[j].coordinates);
                textCoords[1] += 5;
                c.fillStyle = textColors, c.textAlign = "center", c.font = "18px FontAwesome", c.fillText(points[j].icon, textCoords[0], textCoords[1]);
                textCoords[0] += 15;
                c.textAlign = "left", c.font = " 12px Roboto", c.fillText(points[j].location, textCoords[0], textCoords[1]);
            }


            console.log(projection.scale());
            if (projection.scale() < middleScale + 50 && projection.scale() > middleScale - 50) {
                zoomingIn = true;
            }
        };
    }

    function restartTransition() {
        i = -1;
        _transition();
    }
});

function changeColors() {
    colorGlobe = "#0288D1";
    colorLand = "#9CCC65";
    textColors = "#000";
}

function flyingArc(path) {
    var source = path.geometry.coordinates[0],
        target = path.geometry.coordinates[1];
        middle = locationAlongArc(source, target, 0.5);
    return [
        projection(source),
        loftedProjection(middle),
        projection(target)
    ];
}

function locationAlongArc(start, end, theta) {
    return d3.geoInterpolate(start, end)(theta);
}

function focusGlobeOnPoint(point, scale) {
    var editablePoint = [point[0], point[1]];
    projection
        .rotate(point)
        .scale(scale);
    editablePoint[1] += 10;
    loftedProjection
        .rotate(point)
        .scale(scale);
}

function lineLength(points) {
    var d = 0;
    for (var i = 0; i < points.length - 1; i++) {
        var x0 = points[0][0],
            y0 = points[0][1],
            x1 = points[1][0],
            y1 = points[1][1],
            dx = x1 - x0,
            dy = y1 - y0;
        d += Math.sqrt(dx * dx + dy * dy);
    }
    return d;
}




</script>